#define LED_SHOW_C
#include "stdarg.h"
#include "stdio.h"
#include "string.h"
#include "math.h"
#include "QT.h"
#include "LED_Cfg.h"
#include "LED_Para.h"
#include "LED_Show.h"

typedef struct{
  INT16U Unicode;
  INT8U CN16_Dot[32]; //16*16
  INT8U CN24_Dot[72]; //24*24
  INT8U CN36_Dot[162]; //36*36
}CNZK_Info;



const CNZK_Info CN_ZK[]=
{
    {0,{0},{0},{0}}
};

//每档速度的延时,单位为毫秒
const INT16U Step_Delay[]=
{
	10,
        20,
	30,
	40,
	50,
	60,
	70,
	80,
	90,
	100
};

typedef struct
{
  void (*Func)(INT8U);
}S_Mode_Func;

//数据移入方式
const S_Mode_Func Mode_Func[]=
{
 {&Move_Left},
 {&Move_Right},
 {&Move_Up},
 {&Move_Down},
 {&Move_Left_Cover},
 {&Move_Right_Cover},
 {&Move_Up_Cover},
 {&Move_Down_Cover},
 {&Move_Left_Up_Cover},
 {&Move_Right_Up_Cover},
 {&Move_Left_Down_Cover},
 {&Move_Right_Down_Cover},
 {&Move_Left_Right_Open},
 {&Move_Up_Down_Open},
 {&Move_Left_Right_Close},
 {&Move_Up_Down_Close},

};

//获取得颜色
INT8U Get_Color()
{
  if(!(Screen_Para.Color <=2))
    return 0;
  else
  {
    return Screen_Para.Color;
  } 
}  

//获取缓冲区中第Index位的值
INT8U Get_Buf_Bit(INT8U Buf[], INT32U Buf_Size, INT16U Index)
{
  if(Index >= Buf_Size * 8)
  {
    ASSERT_FAILED();
    return 0;
  }
  
  return (Buf[Index / 8] & (0x01 << (Index % 8)))>0?1:0;
}

//设置缓冲区中第Index位的值
void Set_Buf_Bit(INT8U Buf[], INT32U Buf_Size, INT16U Index, INT8U Value)
{
  if(Index >= Buf_Size * 8)
  {
    ASSERT_FAILED();
    return;
  }
  
  if(Value EQ 0)
    Buf[Index / 8] = (Buf[Index / 8] & (~(0x01 << (Index % 8))));
  else
    Buf[Index / 8] = (Buf[Index / 8] | (0x01 << (Index % 8)));
}

//获取区域中某点的索引
INT32U Get_Area_Point_Index(INT8U Area_No, INT16U X, INT16U Y)
{
  INT32U Index;
  
  if(Area_No > MAX_AREA_NUM)
  {
    ASSERT_FAILED();
    return 0;	
  }
  
  if(Program_Para.Area[Area_No].X + X > Screen_Para.Width ||\
    Program_Para.Area[Area_No].Y + Y > Screen_Para.Height)
  {
    ASSERT_FAILED();
    return 0;
  }
  
  //该区域的起始位置
  Index = (INT32U)Screen_Para.Width * (Program_Para.Area[Area_No].Y) + (Program_Para.Area[Area_No].X);
  //该区域内的位置偏移
  Index += Program_Para.Area[Area_No].X_Len * Y + X;	
  
  return Index;
}

//当前节目的某点数据,第0位到第2位分别为三种颜色
INT8U Get_Area_Point_Data(S_Show_Data *pSrc_Buf, INT8U Area_No, INT16U X, INT16U Y) //获取一个区域内一个点的数据
{
  INT32U Index;
  
  Index = Get_Area_Point_Index(Area_No, X, Y);
  
  if(Screen_Para.Color EQ 0)  //单色屏
    return Get_Buf_Bit(pSrc_Buf->One_Color_Data.Color0, sizeof(pSrc_Buf->One_Color_Data.Color0),Index);
  else if(Screen_Para.Color EQ 1) //双色屏
    return Get_Buf_Bit(pSrc_Buf->Two_Color_Data.Color0, sizeof(pSrc_Buf->Two_Color_Data.Color0), Index) +\
      (Get_Buf_Bit(pSrc_Buf->Two_Color_Data.Color1, sizeof(pSrc_Buf->Two_Color_Data.Color1), Index) << 1);
  else if(Screen_Para.Color EQ 2) //三色屏
    return Get_Buf_Bit(pSrc_Buf->Three_Color_Data.Color0, sizeof(pSrc_Buf->Two_Color_Data.Color0), Index) + \
      (Get_Buf_Bit(pSrc_Buf->Three_Color_Data.Color1, sizeof(pSrc_Buf->Three_Color_Data.Color1), Index) << 1) +\
      (Get_Buf_Bit(pSrc_Buf->Three_Color_Data.Color2, sizeof(pSrc_Buf->Three_Color_Data.Color2), Index) << 2);
  else
    return 0;
} 

//设置某节目区域中某点的数据,第0-2位分别表示三种颜色
void Set_Area_Point_Data(S_Show_Data *pDst_Buf, INT8U Area_No, INT16U X, INT16U Y, INT8U Value) //设置一个区域的点   
{
  INT32U Index;
  
  Index = Get_Area_Point_Index(Area_No, X, Y);
  
  if(Screen_Para.Color EQ 0)  //单色屏
    Set_Buf_Bit(pDst_Buf->One_Color_Data.Color0, sizeof(pDst_Buf->One_Color_Data.Color0),Index, (Value & 0x01));
  else if(Screen_Para.Color EQ 1) //双色屏
  {
    Set_Buf_Bit(pDst_Buf->Two_Color_Data.Color0, sizeof(pDst_Buf->Two_Color_Data.Color0), Index, (Value & 0x01));
    Set_Buf_Bit(pDst_Buf->Two_Color_Data.Color1, sizeof(pDst_Buf->Two_Color_Data.Color1), Index, (Value & 0x02)>>1);
  }
  else if(Screen_Para.Color EQ 2) //三色屏
  {
    Set_Buf_Bit(pDst_Buf->Three_Color_Data.Color0, sizeof(pDst_Buf->Three_Color_Data.Color0), Index, (Value & 0x01));
    Set_Buf_Bit(pDst_Buf->Three_Color_Data.Color1, sizeof(pDst_Buf->Three_Color_Data.Color1), Index, (Value & 0x02)>>1);
    Set_Buf_Bit(pDst_Buf->Three_Color_Data.Color2, sizeof(pDst_Buf->Three_Color_Data.Color2), Index, (Value & 0x04)>>2);
  }
} 

//复制一个方形区域
//pSrc_Buf 原显示数据缓冲区
//
void Copy_Rect_Data(S_Show_Data *pSrc_Buf, INT8U Area_No, S_Point *pSrc_Point, INT16U X_Len, INT16U Y_Len,\
  S_Show_Data *pDst_Buf, S_Point *pDst_Point) //复制一个方形区域
{

}

S_Point * Get_Left_Point(S_Point *pPoint0, S_Point *pPoint1)
{
  if(pPoint0->X < pPoint1->X) //point0在最左边
  {
    return pPoint0;
  }
  else
  {
    return pPoint1;
  }  
}

S_Point * Get_Right_Point(S_Point *pPoint0, S_Point *pPoint1)
{
  if(pPoint0->X > pPoint1->X) //point0在最左边
  {
   return pPoint0;
  }
  else
  {
    return pPoint1;
  }  
}

//复制一条线
void Copy_Line(S_Show_Data *pSrc_Buf, INT8U Area_No, S_Point *pPoint0, S_Point *pPoint1, \
                   S_Show_Data *pDst_Buf, S_Point *pPoint2)  //复制一个三角形区域
{
  INT8U Data;
  S_Point *pLeft, *pRight;
  INT32S i,j;
  
  pLeft = Get_Left_Point(pPoint0, pPoint1);
  pRight = Get_Right_Point(pPoint0, pPoint1);
  
  for(i = pLeft -> X + 1; i <= pRight->X ; i ++)
  {
    j = GET_LINE_Y((INT32S)pLeft->X,(INT32S)pLeft->Y, (INT32S)pRight->X, (INT32S)pRight->Y, i);//(INT32S)pLeft->Y + (INT32S)(i - pLeft ->X)((INT32S)(pRgiht->Y) - (INT32S)(pLeft->Y))/(pRight -> X - pLeft->X) ;  
  
    if(j < 0)
      ASSERT_FAILED();
    
    Data = Get_Area_Point_Data(pSrc_Buf, Area_No, (INT16U)i, (INT16U)j);
    Set_Area_Point_Data(pDst_Buf, Area_No, (INT16U)(i + pPoint2->X - pPoint0->X), (INT16U)(j + pPoint2->Y - pPoint0->Y), Data);
  }
}

//填充一条线
void Fill_Line(S_Show_Data *pDst_Buf, INT8U Area_No, S_Point *pPoint0, S_Point *pPoint1, INT8U Value)
{
  S_Point *pLeft, *pRight;
  INT32S i,j;
  
  pLeft = Get_Left_Point(pPoint0, pPoint1);
  pRight = Get_Right_Point(pPoint0, pPoint1);
  
  for(i = pLeft -> X + 1; i <= pRight->X ; i ++)
  {
    j = GET_LINE_Y((INT32S)pLeft->X,(INT32S)pLeft->Y, (INT32S)pRight->X, (INT32S)pRight->Y, i);//(INT32S)pLeft->Y + (INT32S)(i - pLeft ->X)((INT32S)(pRgiht->Y) - (INT32S)(pLeft->Y))/(pRight -> X - pLeft->X) ;  
  
    if(j < 0)
      ASSERT_FAILED();
    
    Set_Area_Point_Data(pDst_Buf, Area_No, (INT16U)i, (INT16U)j, Value);
  }
  
  
}

//复制一个三角形数据--限直角三角形
void Copy_Triangle(S_Show_Data *pSrc_Buf, INT8U Area_No, S_Point *pPoint0, S_Point *pPoint1,S_Point *pPoint2,\
                       S_Show_Data *pDst_Buf, S_Point *pPoint3)  //复制一个三角形区域

{
  S_Point *pLeft;  //最左边的点
  S_Point *pRight; //最右边的点
  S_Point Temp;
  S_Point Temp1;
  
  pLeft = Get_Left_Point(pPoint0, pPoint1);
  pRight = Get_Right_Point(pPoint0, pPoint1);

  Temp.X = pLeft -> X;  //中间的X

  while(Temp.X != pRight -> X)
  {
    Temp.Y = GET_LINE_Y((INT32S)pLeft ->X, (INT32S)pLeft->Y, (INT32S)pRight->X, (INT32S)pRight->Y, (INT32S)Temp.X);
    Temp1.X = (INT16U)((INT32S)Temp.X + (INT32S)(pPoint3 -> X) - (INT32S)(pPoint0 -> X));
    Temp1.Y = (INT16U)((INT32S)Temp.Y + (INT32S)(pPoint3 -> Y) - (INT32S)(pPoint0 -> Y));
    Copy_Line(pSrc_Buf, Area_No, &Temp, pPoint2, pDst_Buf, &Temp1);
  }
}

//填充一个区域
void Fill_Triangle(S_Show_Data *pDst_Buf, INT8U Area_No, S_Point *pPoint0, S_Point *pPoint1,S_Point *pPoint2, INT8U Value)
{
  S_Point *pLeft;  //最左边的点
  S_Point *pRight; //最右边的点
  S_Point Temp;
  
  pLeft = Get_Left_Point(pPoint0, pPoint1);
  pRight = Get_Right_Point(pPoint0, pPoint1);

  Temp.X = pLeft -> X;  //中间的X

  while(Temp.X != pRight -> X)
  {
    Temp.Y = GET_LINE_Y((INT32S)pLeft ->X, (INT32S)pLeft->Y, (INT32S)pRight->X, (INT32S)pRight->Y, (INT32S)Temp.X);
    Fill_Line(pDst_Buf, Area_No, &Temp, pPoint2, Value);
  }
}

//复制一个多边形
void Copy_Polygon(S_Show_Data *pSrc_Buf, INT8U Area_No, S_Point *pPoint0, S_Point *pPoint1,S_Point *pPoint2, S_Point *pPoint3,\
                       S_Show_Data *pDst_Buf, S_Point *pPoint4)
{
  Copy_Triangle(pSrc_Buf, Area_No, pPoint0, pPoint1, pPoint2, pDst_Buf, pPoint4);
  Copy_Triangle(pSrc_Buf, Area_No, pPoint0, pPoint2, pPoint3, pDst_Buf, pPoint4);
}

//填充一个多边形
void Fill_Polygon(S_Show_Data *pDst_Buf, INT8U Area_No, S_Point *pPoint0, S_Point *pPoint1,S_Point *pPoint2, S_Point *pPoint3, INT8U Value)
{
  Fill_Triangle(pDst_Buf, Area_No, pPoint0, pPoint1, pPoint2, Value);
  Fill_Triangle(pDst_Buf, Area_No, pPoint0, pPoint2, pPoint3, Value);  
}

//复制一个矩形
void Copy_Rect(S_Show_Data *pSrc_Buf, INT8U Area_No, S_Point *pPoint0, INT16U X_Len, INT16U Y_Len,\
                       S_Show_Data *pDst_Buf, S_Point *pPoint1)
{
  INT16U i,j;
  INT8U Data;
  
  for(i = 0; i < Program_Para.Area[Area_No].X_Len;  i++)
    for(j = 0; j < Program_Para.Area[Area_No].Y_Len; j++)
    {
      Data = Get_Area_Point_Data(pSrc_Buf, Area_No, i, j); 
      Set_Area_Point_Data(pDst_Buf, Area_No, i, j, Data); 
    }  
}

//填充一个矩形
void Fill_Rect(S_Show_Data *pDst_Buf, INT8U Area_No, S_Point *pPoint0, INT16U X_Len, INT16U Y_Len,INT8U Value)
{
  INT16U i,j;
  //INT8U Data;
  
  for(i = 0; i < Program_Para.Area[Area_No].X_Len;  i++)
    for(j = 0; j < Program_Para.Area[Area_No].Y_Len; j++)
    {
      //Data = Get_Area_Point_Data(pSrc_Buf, Area_No, i, j); 
      Set_Area_Point_Data(pDst_Buf, Area_No, i, j, Value);  
    }
}


//填充一个圆形
void Fill_Round(S_Show_Data *pDst_Buf, INT8U Area_No, S_Point *pCenter, INT16U Radius, INT8U Value)
{
  S_Point Up, Down;
  INT16U Temp,X;
  
  X = pCenter -> X - Radius; //最左边一点的X坐标
  
  for(; X <= pCenter -> X + Radius; X ++)
  {
     Temp = (INT16U)sqrt((float)(Radius * Radius - (INT16U)((INT32S)X - (INT32S)pCenter->X)*((INT32S)X - (INT32S)pCenter->X)));
     //上面一点
     Up.Y = pCenter->Y + Temp;
     Up.X = X;
     //下面一点
     Down.Y = pCenter->Y- Temp;
     Down.X = X;
     Fill_Line(pDst_Buf, Area_No, &Down, &Up, Value);
  }
}

//复制一个实心圆
void Copy_Round(S_Show_Data *pSrc_Buf, INT8U Area_No, S_Point *pCenter0, INT16U Radius, S_Show_Data *pDst_Buf, S_Point *pCenter1)
{
  S_Point Up, Down,Temp;
  INT16U X,Temp1;
  
  X = pCenter0 -> X - Radius; //最左边一点的X坐标
  
  for(; X <= pCenter0 -> X + Radius; X ++)
  {
     Temp1 = (INT16U)sqrt((float)(Radius * Radius - (INT16U)((INT32S)X - (INT32S)pCenter0->X)*((INT32S)X - (INT32S)pCenter0->X)));
     //上面一点
     Up.Y = pCenter0->Y + Temp1;
     Up.X = X;
     //下面一点
     Down.Y = pCenter0->Y- Temp1;
     Down.X = X;
     
     Temp.X = (INT16U)((INT32S)Up.X + (INT32S)(pCenter1 -> X) - (INT32S)(pCenter0 -> X));
     Temp.Y = (INT16U)((INT32S)Up.Y + (INT32S)(pCenter1 -> Y) - (INT32S)(pCenter0 -> Y));

     Copy_Line(pSrc_Buf,Area_No, &Up, &Down, pDst_Buf, &Temp);
  }
}

//上移
void Move_Up(INT8U Area_No)//上移动
{
  S_Point Temp;
  S_Point Temp1;
  
  if(Area_Status[Area_No].Step < 100) //是否已经移动完成100%
  {
    Temp.X = 0;//Program_Para.Area[Area_No].X;
    Temp.Y = 0;//Program_Para.Area[Area_No].Y;
    
    Temp1.X = 0;//Program_Para.Area[Area_No].X;// + Step +
    Temp1.Y = (100 - Area_Status[Area_No].Step) * Program_Para.Area[Area_No].Y_Len / 100;

    Copy_Rect(&Show_Data_Bak, Area_No, &Temp, Program_Para.Area[Area_No].X_Len, Area_Status[Area_No].Step * Program_Para.Area[Area_No].Y_Len / 100,\
              &Show_Data, &Temp1);
    Area_Status[Area_No].Step += MOVE_STEP;
  } 
}

//下移
void Move_Down(INT8U Area_No)
{
  S_Point Temp;
  S_Point Temp1;
  
  if(Area_Status[Area_No].Step < 100) //是否已经移动完成100%
  {
    Temp.X = 0;//Program_Para.Area[Area_No].X;// + Step +
    Temp.Y = (100 - Area_Status[Area_No].Step) * Program_Para.Area[Area_No].Y_Len / 100;

    Temp1.X = 0;//Program_Para.Area[Area_No].X;
    Temp1.Y = 0;//Program_Para.Area[Area_No].Y;
    
    Copy_Rect(&Show_Data_Bak, Area_No, &Temp, Program_Para.Area[Area_No].X_Len, Area_Status[Area_No].Step * Program_Para.Area[Area_No].Y_Len / 100,\
              &Show_Data, &Temp1);
    Area_Status[Area_No].Step += MOVE_STEP;
  } 
}

//左移
void Move_Left(INT8U Area_No)
{
  S_Point Temp;
  S_Point Temp1;
  
  if(Area_Status[Area_No].Step < 100) //是否已经移动完成100%
  {
    Temp.X = 0;//Program_Para.Area[Area_No].X;
    Temp.Y = 0;//Program_Para.Area[Area_No].Y;
    
    Temp1.X = (100 - Area_Status[Area_No].Step) * Program_Para.Area[Area_No].X_Len / 100;// + Step +
    Temp1.Y = 0;

    Copy_Rect(&Show_Data_Bak, Area_No, &Temp, Area_Status[Area_No].Step * Program_Para.Area[Area_No].X_Len / 100,Program_Para.Area[Area_No].Y_Len, \
              &Show_Data, &Temp1);
    Area_Status[Area_No].Step += MOVE_STEP;
  }   
}

//右边移
void Move_Right(INT8U Area_No)
{
  S_Point Temp;
  S_Point Temp1;
  
  if(Area_Status[Area_No].Step < 100) //是否已经移动完成100%
  {
    Temp.X = (100 - Area_Status[Area_No].Step) * Program_Para.Area[Area_No].Y_Len / 100;// + Step +
    Temp.Y = 0;

    Temp1.X = 0;//Program_Para.Area[Area_No].X;
    Temp1.Y = 0;//Program_Para.Area[Area_No].Y;
    
    Copy_Rect(&Show_Data_Bak, Area_No, &Temp,  Area_Status[Area_No].Step * Program_Para.Area[Area_No].X_Len / 100,Program_Para.Area[Area_No].Y_Len,\
              &Show_Data, &Temp1);
    Area_Status[Area_No].Step += MOVE_STEP;
  } 
}

//上划
void Move_Up_Cover(INT8U Area_No)
{
  S_Point Temp;
  
  if(Area_Status[Area_No].Step < 100) //是否已经移动完成100%
  {
    Temp.X = 0;// + (100 - Area_Status[Area_No].Step) * Program_Para.Area[Area_No].Y_Len / 100;
    Temp.Y = (100 - Area_Status[Area_No].Step) * Program_Para.Area[Area_No].Y_Len / 100;
    
    Copy_Rect(&Show_Data_Bak, Area_No, &Temp, Program_Para.Area[Area_No].X_Len, MOVE_STEP * Program_Para.Area[Area_No].Y_Len / 100,\
              &Show_Data, &Temp);
    Area_Status[Area_No].Step += MOVE_STEP;
  }  
}

//下划
void Move_Down_Cover(INT8U Area_No)
{
  S_Point Temp;
  
  if(Area_Status[Area_No].Step < 100) //是否已经移动完成100%
  {
    Temp.X = 0;// + Step +
    Temp.Y = Area_Status[Area_No].Step * Program_Para.Area[Area_No].Y_Len / 100;

    Copy_Rect(&Show_Data_Bak, Area_No, &Temp, Program_Para.Area[Area_No].X_Len, MOVE_STEP * Program_Para.Area[Area_No].Y_Len / 100,\
              &Show_Data, &Temp);
    Area_Status[Area_No].Step += MOVE_STEP;
  }  
}

//左划
void Move_Left_Cover(INT8U Area_No)
{
  S_Point Temp;
  
  if(Area_Status[Area_No].Step < 100) //是否已经移动完成100%
  {
    Temp.X = (100 - Area_Status[Area_No].Step) * Program_Para.Area[Area_No].X_Len / 100;// + Step +
    Temp.Y = 0;

    Copy_Rect(&Show_Data_Bak, Area_No, &Temp, MOVE_STEP * Program_Para.Area[Area_No].X_Len / 100, Program_Para.Area[Area_No].Y_Len,\
              &Show_Data, &Temp);
    Area_Status[Area_No].Step += MOVE_STEP;
  }  
}

//右划
void Move_Right_Cover(INT8U Area_No)
{
  S_Point Temp;
  S_Point Temp1;
  
  if(Area_Status[Area_No].Step < 100) //是否已经移动完成100%
  {
    Temp.X = Area_Status[Area_No].Step * Program_Para.Area[Area_No].Y_Len / 100;// + Step +
    Temp.Y = 0;
    
    Copy_Rect(&Show_Data_Bak, Area_No, &Temp,  MOVE_STEP * Program_Para.Area[Area_No].X_Len / 100,Program_Para.Area[Area_No].Y_Len,\
              &Show_Data, &Temp1);
    Area_Status[Area_No].Step += MOVE_STEP;
  }  
}

//左上划
void Move_Left_Up_Cover(INT8U Area_No)
{
  S_Point Left,Up,Right;
  
  if(Area_Status[Area_No].Step < 100)
  {
    Left.X = (100 - Area_Status[Area_No].Step)*Program_Para.Area[Area_No].X_Len / 100;
    Left.Y = Program_Para.Area[Area_No].Y_Len;
    
    Up.X = Program_Para.Area[Area_No].X_Len;
    Up.Y = (100 - Area_Status[Area_No].Step)*Program_Para.Area[Area_No].Y_Len / 100;
  
    Right.X = Program_Para.Area[Area_No].X_Len;
    Right.Y = Program_Para.Area[Area_No].Y_Len;
    
    Copy_Triangle(&Show_Data_Bak, Area_No, &Left, &Up, &Right, &Show_Data, &Left);
    Area_Status[Area_No].Step += MOVE_STEP;
  }
}

//右上划
void Move_Right_Up_Cover(INT8U Area_No)
{
  S_Point Left,Up,Right;
  
  if(Area_Status[Area_No].Step < 100)
  {
    Left.X = 0;//Program_Para.Area[Area_No].X;
    Left.Y = Program_Para.Area[Area_No].Y_Len;

    Right.X = Area_Status[Area_No].Step * Program_Para.Area[Area_No].X_Len / 100;
    Right.Y = Program_Para.Area[Area_No].Y_Len;
    
    Up.X = 0;//Program_Para.Area[Area_No].X;
    Up.Y = (100 - Area_Status[Area_No].Step)*Program_Para.Area[Area_No].Y_Len / 100;

    Copy_Triangle(&Show_Data_Bak, Area_No, &Left, &Up, &Right, &Show_Data, &Left);
    Area_Status[Area_No].Step += MOVE_STEP;
  }
  
}

//左下划
void Move_Left_Down_Cover(INT8U Area_No)
{
  S_Point Left,Up,Right;
  
  if(Area_Status[Area_No].Step < 100)
  {
    Left.X = (100 - Area_Status[Area_No].Step)*Program_Para.Area[Area_No].X_Len / 100; 
    Left.Y = 0;

    Right.X = Program_Para.Area[Area_No].X_Len;
    Right.Y = Area_Status[Area_No].Step * Program_Para.Area[Area_No].Y_Len / 100;

    Up.X = Program_Para.Area[Area_No].X_Len;
    Up.Y = 0;
    
    Copy_Triangle(&Show_Data_Bak, Area_No, &Left, &Up, &Right, &Show_Data, &Left);
    Area_Status[Area_No].Step += MOVE_STEP;
  }  
}

//右下划
void Move_Right_Down_Cover(INT8U Area_No)
{
  S_Point Left,Up,Right;
  
  if(Area_Status[Area_No].Step < 100)
  {
    Left.X = 0;// + (100 - Area_Status[Area_No].Step)*Program_Para.Area[Area_No].X_Len / 100; 
    Left.Y = Area_Status[Area_No].Step * Program_Para.Area[Area_No].Y_Len / 100;

    Right.X = Area_Status[Area_No].Step * Program_Para.Area[Area_No].Y_Len / 100;
    Right.Y = 0;// + Area_Status[Area_No].Step * Program_Para.Area[Area_No].Y_Len / 100;

    Up.X = 0;// + Program_Para.Area[Area_No].X_Len;
    Up.Y = 0;
    
    Copy_Triangle(&Show_Data_Bak, Area_No, &Left, &Up, &Right, &Show_Data, &Left);
    Area_Status[Area_No].Step += MOVE_STEP;
  }  
}

//上下拉帘
void Move_Up_Down_Open(INT8U Area_No)
{
  S_Point Temp;
  
  if(Area_Status[Area_No].Step < 100)
  {
    Temp.X = 0;
    Temp.Y = (100 - Area_Status[Area_No].Step)*Program_Para.Area[Area_No].Y_Len / 200; 
    Copy_Rect(&Show_Data_Bak, Area_No, &Temp, Program_Para.Area[Area_No].X_Len, Area_Status[Area_No].Step * Program_Para.Area[Area_No].Y_Len / 100, &Show_Data, &Temp);
    Area_Status[Area_No].Step += MOVE_STEP;
  }
  
}

//上下合帘
void Move_Up_Down_Close(INT8U Area_No)
{
  S_Point Temp;
  
  if(Area_Status[Area_No].Step < 100)
  {
    Temp.X = 0;
    Temp.Y = 0;// + Area_Status[Area_No].Step * Program_Para.Area[Area_No].Y_Len / 200; 
    Copy_Rect(&Show_Data_Bak, Area_No, &Temp, Program_Para.Area[Area_No].X_Len, Area_Status[Area_No].Step * Program_Para.Area[Area_No].Y_Len / 200, &Show_Data, &Temp);

    Temp.X = 0;
    Temp.Y = Program_Para.Area[Area_No].Y_Len - Area_Status[Area_No].Step * Program_Para.Area[Area_No].Y_Len / 200; 
    Copy_Rect(&Show_Data_Bak, Area_No, &Temp, Program_Para.Area[Area_No].X_Len, Area_Status[Area_No].Step * Program_Para.Area[Area_No].Y_Len / 200, &Show_Data, &Temp);
    Area_Status[Area_No].Step += MOVE_STEP;
  }  
}

//左右开帘
void Move_Left_Right_Open(INT8U Area_No)
{
  S_Point Temp;
  
  if(Area_Status[Area_No].Step < 100)
  {
    Temp.X = (100 - Area_Status[Area_No].Step)*Program_Para.Area[Area_No].X_Len / 200;
    Temp.Y = 0; 
    Copy_Rect(&Show_Data_Bak, Area_No, &Temp,  Area_Status[Area_No].Step * Program_Para.Area[Area_No].X_Len / 100, Program_Para.Area[Area_No].Y_Len, &Show_Data, &Temp);
    Area_Status[Area_No].Step += MOVE_STEP;
  }
    
}

//左右合帘
void Move_Left_Right_Close(INT8U Area_No)
{
  S_Point Temp;
  
  if(Area_Status[Area_No].Step < 100)
  {
    Temp.X = 0;
    Temp.Y = 0;// + Area_Status[Area_No].Step * Program_Para.Area[Area_No].Y_Len / 200; 
    Copy_Rect(&Show_Data_Bak, Area_No, &Temp, Area_Status[Area_No].Step * Program_Para.Area[Area_No].X_Len / 200, Program_Para.Area[Area_No].Y_Len,  &Show_Data, &Temp);

    Temp.X = Program_Para.Area[Area_No].X_Len - Area_Status[Area_No].Step * Program_Para.Area[Area_No].X_Len / 200;
    Temp.Y = 0; 
    Copy_Rect(&Show_Data_Bak, Area_No, &Temp, Area_Status[Area_No].Step * Program_Para.Area[Area_No].X_Len / 200, Program_Para.Area[Area_No].Y_Len, &Show_Data, &Temp);
    Area_Status[Area_No].Step += MOVE_STEP;
  }  
}


//显示表盘
void Show_Dial(INT8U Area_No, S_Dial_Para Dial_Para)
{
  
  
  
}

//获取某个窗口区域某个步进的停留时间
INT8U Get_Area_Step_Delay(INT8U Area_No)
{
	INT8U Step;
	
	if(Area_No >= MAX_AREA_NUM)
		{
		  ASSERT_FAILED();
                  return Step_Delay[0];
		}
		
	Step = File_Para[Area_No].In_Speed; //引入速度
        if(Step >= sizeof(Step_Delay)/sizeof(Step_Delay))
                Step = sizeof(Step_Delay)/sizeof(Step_Delay);
		
	return Step_Delay[Step];
}

//获取文件的停留时间,单位为ms
//原参数最高为表示单位，0为s，1为ms
INT32U Get_File_Stay_Time(INT8U Area_No)
{
        if((File_Para[Area_No].Stay_Time & 0x8000) > 0)
                return (INT32U)(File_Para[Area_No].Stay_Time & 0x7FFF);
        else
                return (INT32U)File_Para[Area_No].Stay_Time * 1000;
}

//显示某个分区数据--->每10ms调用该函数，实现动画或移动等
//调用此函数前，显示数据已经读取在Show_Data_Bak中，同时Area_Status和Program_Para等信息已经保存好
void Update_Area_Data(INT8U Area_No)
{
    INT8U In_Mode;
	//还在移动状态
	if(Area_Status[Area_No].Step < 100)
	{
                if(Area_Status[Area_No].Step_Timer < Get_Area_Step_Delay(Area_No))
			Area_Status[Area_No].Step_Timer += MOVE_STEP_TIMER;
	  else
	  {
	  	In_Mode = File_Para[Area_No].In_Mode;
                (*(Mode_Func[In_Mode]))(Area_No);//执行移动操作
	  }
	}
	else if(Area_Status[Area_No].Stay_Time <= Get_File_Stay_Time(Area_No)) //停留时间未到
	{
		Area_Status[Area_No].Stay_Time += MOVE_STEP_TIMER;
	}
}

//每隔MOVE_STEP_TIMER ms调用该函数,实现移动显示等效果
void Update_Show_Data()
{
	INT8U i;
	//static S_Int8U Ms10_Timer
	for(i = 0; i < MAX_AREA_NUM; i ++)
	{
		Update_Area_Data(i);
	}
}

//检测更新显示备份区数据
void Check_Update_Show_Data_Bak()
{
	INT8U i;
	
	for(i = 0; i < Program_Para.Area_Num && i < MAX_AREA_NUM; i ++)
	{
		//目前显示的步进已经到100%并且目前停留时间已经达到文件的停留时间，则认为该屏已经显示完毕，切换到下屏
		if(Get_File_Stay_Time(i) < MIN_STAY_TIME)
			Set_File_Stay_Time(i, MIN_STAY_TIME);
			
		if(Area_Status[i].Step >= 100 && Area_Status[i].Stay_Time >= Get_File_Stay_Time(i))
	    Update_Show_Data_Bak(Program_Para.Program_No, i) 
	}	
}

INT8U Get_Bit(INT8U *p,INT16U X_Size,INT16U X,INT16U Y)
{
  if((*(p+(Y/8)*(X_Size)+X))&(0x01<<(Y%8)))
    return 0x01;
  else
    return 0x00;
  
}

void Show_Char(INT16U Unicode,INT8U Area_No, INT16U X,INT16U Y,INT8U Size_Flag)
{
  INT16U i,j,k;
  INT8U Bit,X_Size,Y_Size;
  //S_Point Point;
  
  for(i=0;i<sizeof(CN_ZK)/sizeof(CN_ZK[0]);i++)
  {
    if(CN_ZK[i].Unicode==Unicode)
    {     
      if(Size_Flag EQ 0)
      {
        X_Size=16;
        Y_Size=16;
      }
      else if(Size_Flag EQ 1)
      {
        X_Size=24;
        Y_Size=24;          
      }
      else
      {
        X_Size=48;
        Y_Size=48;
      }
      
      if(Unicode < 0xA0A0) //英文宽度-1
      {
        X_Size=X_Size / 2;           
      }//
      
      for(j=0;j<X_Size;j++)
        for(k=0;k<Y_Size;k++)
        {
          if(Size_Flag EQ 0)            
            Bit=Get_Bit((INT8U *)CN_ZK[i].CN16_Dot,X_Size,j,k);
          else if(Size_Flag EQ 1)
            Bit=Get_Bit((INT8U *)CN_ZK[i].CN24_Dot,X_Size,j,k);
          else
            Bit=Get_Bit((INT8U *)CN_ZK[i].CN36_Dot,X_Size,j,k);
          
          Set_Area_Point_Data(&Show_Data_Bak, Area_No, X + j, Y +k, Bit);          
        }
    }   
  }
}

//根据format和ap参数表输出调试信息
void Printf(INT8U Area_No, INT16U X, INT16U Y, INT8U Size_Flag, const INT8S *format, va_list ap)
{
  
  static const INT8S Chr[]="0123456789ABCDEF";

  static const INT32U Oct[12]=
  {
    01,010,0100,01000,010000,0100000,01000000,010000000,
    0100000000,01000000000,010000000000,010000000000,
  }; //八进制
  static const INT32U Dec[11]=
  {
    1,10,100,1000,10000,100000,1000000,
    10000000,100000000,1000000000,1000000000,
  }; //十进制
  static const INT32U Hex[8]=
  {
    0x1,0x10,0x100,0x1000,0x10000,
    0x100000,0x1000000,0x10000000,
  }; //十六进制
  
  INT8U LintFlag;
  INT32U const *p;
  INT8S *pSrc;
  
  unsigned long int uParaValue;//无符号数
  long int sParaValue;//有符号数
  
  INT8U c;
  INT8U i,Width,Len;
 
  for(;;)    //遍历整个参数表
  {
    while((c=*format++)!='%')//%符号之前全是字符串
    {
      if(!c)
        return;
      Show_Char(Area_No, X, Y,c,Size_Flag);
    }

    c=*format++;
    //非数值类型处理
    switch(c)
    {
      case 'c':
        c = va_arg(ap, int);
        Show_Char(Area_No, X, Y,c,Size_Flag);
        break;
      case 's':
        pSrc= va_arg(ap,INT8S *);
        while((c = *pSrc++)!=0)
          Show_Char(Area_No, X, Y,c,Size_Flag);
        break;
      default:
        break;
    }
    
    //数值类型处理
    if(c>='1' && c<='9')
    {
      Width=c-'0';
      c=*format++;
    }
    else
      Width=1;//至少打印一个字符
    
    if(c EQ 'l' || c EQ 'L')//是否是一个长整形?
    {
      LintFlag=1;
      c=*format++;
    }
    else
      LintFlag=0;
    
    switch(c)//打印数据类型
    {
      case 'o':
        p=Oct;
        Len=12;
        break;
      case 'd':
      case 'u':
        p=Dec;
        Len=11;
        break;
      case 'x':
        p=Hex;
        Len=8;
        break;

      default:
        continue;
    }
    
    //获取参数数值
    if(c EQ 'd')//有符号数
    {
      if(LintFlag)//长整型
        sParaValue=va_arg(ap,long int);
      else
        sParaValue=va_arg(ap,int);
      
      if(sParaValue<0)
      {
        Show_Char(Area_No, X, Y, '-',Size_Flag);
        sParaValue=0-sParaValue;
      }
      uParaValue=(unsigned long int)sParaValue;//赋值到uParaValue,统一计算
    }
    else//无符号数
    {
      if(LintFlag)//长整型
        uParaValue=va_arg(ap,unsigned long int);
      else
        uParaValue=va_arg(ap,INT16U);  
    }
    
    //计算数据本身的长度
    for(i=0;i<Len;i++)
    {
       if(uParaValue<*(p+i))
         break;
    }
    
    if(Width<i)//i表示数据本身长度，Width表示需要打印的长度
      Width=i;
    
    //分别打印每个字符
    i=0;//表示是否已经找到了一个非0位
    for(;Width!=0;Width--)
    {
      c=(INT8U)(uParaValue/(*(p+Width-1)));
      uParaValue=uParaValue%(*(p+Width-1));
      //前面的0全部打成空格

      if(c EQ 0 && i EQ 0 && Width>1)//该位为0，且之前的位也都为0,且不是最后一位(数值本身为0)
        c=' ';
      else
      {
        i=1;//表示已经有一个非0位了
        c=Chr[c];
      }
      Show_Char(Area_No, X, Y,c,Size_Flag);
    }
  }
}
